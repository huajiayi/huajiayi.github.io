<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C语言学习-指针]]></title>
    <url>%2Fblog4.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样，例如 int 占用4个字节，float 占用8个字节，char 占用1个字节。为了正确地访问这些数据，必须为每个字节都编上号码，就像门牌号、身份证号一样，每个字节的编号是唯一的，根据编号可以准确地找到某个字节。 指针的定义和使用指针和指针变量指针（Pointer）就是内存的地址，C语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以及其他指针变量的地址。 定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号*，格式为： datatype * name; *表示这是一个指针变量，datatype表示该指针变量所指向的数据的类型 。例如： int a = 100; int *p_a = &amp;a; 在定义指针变量 p_a 的同时对它进行初始化，并将变量 a 的地址赋予它，此时 p_a 就指向了 a。值得注意的是，p_a 需要的一个地址，a 前面必须要加取地址符&amp;，否则是不对的。 现在p_a代表的是a的地址，那么*p_a也就是a的值，例如： *p_a = 200; 这样做就把a的值赋成了200。 指针使用热身int i = 20; int k = 10; int * p = &amp;k; int * o; int * a; p = &amp;i; //把指针变量p从指向k变成指向i //o = p; printf(&quot;*p = %d\n&quot;, *p); //输出*p也就是i的值 printf(&quot;o = %x\n&quot;, o); //输出*o的内存地址，如果不分配内存地址，自动为cccccccc，又因为里面的值是垃圾值，所以不能被读写，运行后程序会报错 printf(&quot;a = %x\n&quot;, a); //输出*a的内存地址 printf(&quot;k = %d\n&quot;, k); return 0; 指针使用实例——2个数字互换# include &lt;stdio.h&gt; void swap(int * a, int * b) { int c; c = *a; *a = *b; *b = c; } int main(void) { int i = 3; int j = 5; char ch = &apos;ab&apos;; swap(&amp;i, &amp;j); printf(&quot;i = %d\nj = %d\n&quot;, i, j); printf(&quot;ch = %c\n&quot;, ch); return 0; } 指针和数组的关系在c语言中，数组名就是数组第0个元素的地址，例如： int arr[3] = {1,2,3}; int * p = arr; 这里*p的值为1，为什么arr前不要取地址符&amp;呢，因为arr就是数组里第0个元素的地址。 数组的内存分配是连续的，所以第0个元素的地址加1就是第一个元素的地址，例如*(p+1)就等价于p[1]。 *(p+1) == p[1]; //true 指针变量占几个字节在c语言中，可以用sizeof()函数来查看变量占用的内存空间，例如： int i = 5; double d = 1.1; char ch = &apos;a&apos;; int * p_i = &amp;i; double * p_d = &amp;d; char * p_ch = &amp;ch; sizeof(i); //4 sizeof(d); //8 sizeof(ch); //1 sizeof(p_i); //4 sizeof(p_d); //4 sizeof(p_ch); //4 可以看到指针变量永远只占4个字节。 malloc动态内存分配传统的数组长度是固定的，也就是静态的，这就有了很大的局限性，所以就出现了动态内存分配，他可以使用户来决定数组的长度，malloc函数就是用来动态分配内存的函数。 静态变量被存放于栈中，而动态变量存放于堆中，栈的特点是先进后出，堆的特点是先进先出。 int len = 4; int * pArr = (int *)malloc(len * sizeof(int)); //等价于pArr[4] 这里要注意，由于malloc函数返回的值是void 类型，所以需要强制转换成int 类型，否则会报错。 多级指针指针可以指向一份普通类型的数据，例如 int、double、char 等，也可以指向一份指针类型的数据，例如 int 、double 、char * 等。 如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针，例如： int a =100; int *p1 = &amp;a; int **p2 = &amp;p1; 指针变量也是一种变量，也会占用存储空间，也可以使用&amp;获取它的地址。C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号。p1 是一级指针，指向普通类型的数据，定义时有一个星号；p2 是二级指针，指向一级指针 p1，定义时有两个*。 如果我们希望再定义一个三级指针 p3，让它指向 p2，那么可以这样写： int ***p3 = &amp;p2; 四级指针也是类似的道理： int ****p4 = &amp;p3;]]></content>
      <categories>
        <category>c语言学习笔记</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言学习-数组]]></title>
    <url>%2Fblog3.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;C语言支持一维数组和多维数组，如果一个数组的所有元素都不是数组，那么该数组被称为一维数组。 一维数组一维数组的定义方式在C语言中使用数组必须先进行定义。一维数组的定义方式为： 数据类型 数组名 [数组长度] = {元素,元素,…} 其中，数组长度指的是数组内元素的个数。例如： int i[5] = {1,2,3,4,5}; //最常用的写法 也可以这样定义： int i[5] = {1,2}; //第3、第4、第5个元素自动赋值为0 int i[5] = {0}; //所有元素都赋值为0 还有一种写法： int i[5]; //不可直接使用，需给元素赋值 i[0] = 1; i[1] = 2; i[2] = 3; //赋值 i[3] = 4; i[4] = 5; 这里要注意，数组的下标是从0开始的，如a[0]表示数组a内的第一个元素。 下列定义方式是错误的： int a = 5; int i[a]; 但是可以这样写： # define a 5 int i[a]; 一维数组的遍历如果想要遍历一个一维数组，可以使用for循环： int a[5] = {1,2,3}; for(i=0; i&lt;5; i++) { printf(&quot;%d &quot;, a[i]); //输出结果为：1 2 3 0 0 } 一维数组的比较如果想要比较两个一维数组中的元素，以下方式是错误的： int a[5] = {1,2,3}; int b[5] = {1,2,3}; a == b; 原因：a指的是数组a内的第一个元素的内存地址，所以结果肯定为false。 正确的写法为： int a[5] = {1,2,3}; int b[5] = {1,2,3}; for(i=0; i&lt;5; i++) { a[i] == b[i]; //结果为true } 选择排序选择排序原理： 第一个元素和其他元素一一比较，如果其他元素的值比较小，则对换两个元素的值，以此获得最小的值，放在数组的第一位。然后第二个元素和第二个元素以后的其他元素进行比较，如果其他元素的值比较小，则对换两个元素的值，以此获得第二小的值，放在数组的第二位，以此类推。 选择排序的实现： # include &lt;stdio.h&gt; int main(void) { int a[10] = {1,8,9,5,2,3,45,12,15,30}; int i; int j; int c; //容器 for(i=0;i&lt;=9;i++) { for(j=i;j&lt;=9;j++) { if(a[i] &gt; a[j+1]) { c = a[i]; a[i] = a[j+1]; a[j+1] = c; } } } printf(&quot;排序后的值为：&quot;); for(i=0;i&lt;=9;i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); return 0; } 二维数组二维数组的定义二维数组的定义方式为： int i[2][3] = { {1,2,3}, {4,5,6} }; 其中2和3代表2行3列。 也可以这样定义： int i[2][3] = {1,2,3,4,5,6}; 不过这种定义方式不推荐，因为不够直观。 二维数组的实例# include &lt;stdio.h&gt; # define row 4 //行 # define col 3 //列 int main(void) { //定义二维数组 int a[row][col] = { {1,3,2}, {5,6,4}, {8,7,9}, {12,11,10} }; //输出排序前的二维数组 int i, j, b, c, t; printf(&quot;排序前：\n&quot;); for(i=0;i&lt;row;i++) { for(j=0;j&lt;col;j++) { printf(&quot;%-3d&quot;, a[i][j]); } printf(&quot;\n&quot;); } printf(&quot;\n&quot;); //输出每行最大值 int max; for(i=0;i&lt;row;i++) { for(j=0;j&lt;col;j++) { if(max &lt; a[i][j]) { max = a[i][j]; } } printf(&quot;第%d行最大值为：%d\n&quot;, i+1, max); } printf(&quot;\n&quot;); //选择排序 for(i=0;i&lt;=&lt;row*col-1;i++) { for(j=i;j&lt;=row*col;j++) { b = i%row; c = j%col; if(a[b][c] &gt; a[b][c+1]) { t = a[b][c]; a[b][c] = a[b][c+1]; a[b][c+1] = t; } } } //输出排序后的二维数组 printf(&quot;排序后：\n&quot;); for(i=0;i&lt;row;i++) { for(j=0;j&lt;col;j++) { printf(&quot;%-3d&quot;, a[i][j]); } printf(&quot;\n&quot;); } return 0; } 多维数组内存中是否存在多维数组？不存在，因为内存是线性一维的。 n维数组可以当做每个元素是n-1维数组的一维数组。 比如： int i[2][3]; 该数组是含有2个元素的一维数组，只不过每个元素都可以再分成3个小元素 int i[2][3][4]; 该数组是含有2个元素的一维数组,只不过每个元素都是3行4列的二维数组]]></content>
      <categories>
        <category>c语言学习笔记</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>冒泡排序</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何免费观看各大视频网站会员/收费视频]]></title>
    <url>%2Fvipjiexi.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近发现几个可以在线免费观看各大视频网站会员/收费视频的地方。我已经测试过了，速度比较稳定。这是优酷的会员视频：一条狗的使命 这是乐视的收费视频：盗墓笔记 在线观看网址： vip视频解析 47Player]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>福利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用GitHub Page+Hexo搭建个人博客（持续更新）]]></title>
    <url>%2FmFirstBlog.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;想要自己搭建个人博客的可以去看一下GitHub+Hexo 搭建个人网站详细教程,写的很详细。下面我会讲一下我在建博客的途中遇到的那些坑，希望看到这篇博客的同学们吸取一下我的教训，少走一些弯路。另外，想要和我交♂朋友或者有什么问题想问我的可以加我QQ：1601939052，我的微信在侧边栏。 搭建博客途中遇到的坑 &emsp;&emsp;花了一天时间完成了博客的建立和一些优化，在其中遇到了很多很多很多的坑（当我看到404的时候那种绝望你能体会到吗）。。但这些坑让我对Hexo有了进一步的了解，也算是好事吧。 坑1：仓库的名字仓库的名字的正确格式是github用户名.github.io，之前没仔细看，随便起了个，果断报错。 坑2：是Git不是GitHubgit是指Git Bash不是GitHub更不是GitHub Shell 坑3：Hexo命令Hexo命令在Git里打，Git要运行在本地Hexo的根目录下。 坑4：_config.yml配置文件_config.yml配置文件的语法非常严格，“:”后面要一定要加上一个空格 坑5：在yourname.github.io的根目录下添加CNAME具体就是在Hexo目录里的source文件下添加一个名为CNAME的文件，注意这个文件是没有后缀的，千万不要设置成.txt文本文件，文件的内容就是域名，格式如： www.huajiayi.top 其他就没什么了，按照教程一步一步做就行。 关于博客的优化把个人博客托管到Github和Coding上Coding是什么？ Coding是国内Git代码托管平台。国内首个Git代码托管平台GitCafe已被Coding收购。也提供page服务。 有Github不就行了吗？为什么还要用Coding？ 很多人都把hexo托管到github上，因为github大家都用的比较久了。但是，你的博客主要访问者肯定还是国内的用户，国内的用户访问coding比github是要快不少的。还可以利用域名解析实现国内的走coding，海外的走github，分流网站的访问。 Coding的优缺点 优点：在国内网站访问速度比GitHub快一些、更利于百度收录 缺点：目前使用Coding Page访问网站时会有广告，大概5s的广告后才能跳转到你的博客，如果受不了的可以买会员，199元/年。如果不想花钱，那还是用Github吧。。 具体实现步骤：把个人博客托管到Github和Coding上]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
</search>